{"source_files":[{"name":"lib/chat.ex","source":"defmodule Chat do\n  @moduledoc \"\"\"\n  Chat keeps the contexts that define your domain\n  and business logic.\n\n  Contexts are also responsible for managing your data, regardless\n  if it comes from the database, an external API or others.\n  \"\"\"\nend","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"lib/chat/application.ex","source":"defmodule Chat.Application do\n  use Application\n\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  def start(_type, _args) do\n    import Supervisor.Spec\n\n    # Define workers and child supervisors to be supervised\n    children = [\n      # Start the Ecto repository\n      supervisor(Chat.Repo, []),\n      # Start the endpoint when the application starts\n      supervisor(ChatWeb.Endpoint, []),\n      # Start your own worker by calling: Chat.Worker.start_link(arg1, arg2, arg3)\n      # worker(Chat.Worker, [arg1, arg2, arg3]),\n    ]\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Chat.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  def config_change(changed, _new, removed) do\n    ChatWeb.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,0,null,null,null]},{"name":"lib/chat/message.ex","source":"defmodule Chat.Message do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n\n  schema \"messages\" do\n    field :message, :string\n    field :name, :string\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(message, attrs) do\n    message\n    |> cast(attrs, [:name, :message])\n    |> validate_required([:name, :message])\n  end\n\n  @doc \"\"\"\n  Load all messages\n  \"\"\"\n  def get_messages(limit \\\\ 20) do\n    Chat.Repo.all(Chat.Message, limit: limit)\n  end\n  \nend","coverage":[null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,3,null,null,null]},{"name":"lib/chat/repo.ex","source":"defmodule Chat.Repo do\n  use Ecto.Repo, otp_app: :chat\n\n  @doc \"\"\"\n  Dynamically loads the repository url from the\n  DATABASE_URL environment variable.\n  \"\"\"\n  def init(_, opts) do\n    {:ok, Keyword.put(opts, :url, System.get_env(\"DATABASE_URL\"))}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/chat_web.ex","source":"defmodule ChatWeb do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface, such\n  as controllers, views, channels and so on.\n\n  This can be used in your application as:\n\n      use ChatWeb, :controller\n      use ChatWeb, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below. Instead, define any helper function in modules\n  and import those modules here.\n  \"\"\"\n\n  def controller do\n    quote do\n      use Phoenix.Controller, namespace: ChatWeb\n      import Plug.Conn\n      import ChatWeb.Router.Helpers\n      import ChatWeb.Gettext\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View, root: \"lib/chat_web/templates\",\n                        namespace: ChatWeb\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller, only: [get_flash: 2, view_module: 1]\n\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      import ChatWeb.Router.Helpers\n      import ChatWeb.ErrorHelpers\n      import ChatWeb.Gettext\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n      import Plug.Conn\n      import Phoenix.Controller\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n      import ChatWeb.Gettext\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/chat_web/channels/room_channel.ex","source":"defmodule ChatWeb.RoomChannel do\n  use ChatWeb, :channel\n\n  def join(\"room:lobby\", payload, socket) do\n    if authorized?(payload) do\n      send(self(), :after_join)\n      {:ok, socket}\n    else\n      {:error, %{reason: \"unauthorized\"}}\n    end\n  end\n\n  # Channels can be used in a request/response fashion\n  # by sending replies to requests from the client\n  def handle_in(\"ping\", payload, socket) do\n    {:reply, {:ok, payload}, socket}\n  end\n\n  # It is also common to receive messages from the client and\n  # broadcast to everyone in the current topic (room:lobby).\n  def handle_in(\"shout\", payload, socket) do\n    Chat.Message.changeset(%Chat.Message{}, payload) |> Chat.Repo.insert \n    broadcast socket, \"shout\", payload\n    {:noreply, socket}\n  end\n\n  # Add authorization logic here as required.\n  defp authorized?(_payload) do\n    true\n  end\n\n  def handle_info(:after_join, socket) do\n    Chat.Message.get_messages()\n    |> Enum.each(fn msg -> push(socket, \"shout\", %{\n        name: msg.name,\n        message: msg.message,\n      }) end)\n    {:noreply, socket} # :noreply\n  end\nend","coverage":[null,null,null,null,3,3,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,null,3,0,0,null,null,null,null]},{"name":"lib/chat_web/channels/user_socket.ex","source":"defmodule ChatWeb.UserSocket do\n  use Phoenix.Socket\n\n  ## Channels\n  # channel \"room:*\", ChatWeb.RoomChannel\n  channel \"room:lobby\", ChatWeb.RoomChannel\n\n\n  ## Transports\n  transport :websocket, Phoenix.Transports.WebSocket\n  # transport :longpoll, Phoenix.Transports.LongPoll\n\n  # Socket params are passed from the client and can\n  # be used to verify and authenticate a user. After\n  # verification, you can put default assigns into\n  # the socket that will be set for all channels, ie\n  #\n  #     {:ok, assign(socket, :user_id, verified_user_id)}\n  #\n  # To deny connection, return `:error`.\n  #\n  # See `Phoenix.Token` documentation for examples in\n  # performing token verification on connect.\n  def connect(_params, socket) do\n    {:ok, socket}\n  end\n\n  # Socket id's are topics that allow you to identify all sockets for a given user:\n  #\n  #     def id(socket), do: \"user_socket:#{socket.assigns.user_id}\"\n  #\n  # Would allow you to broadcast a \"disconnect\" event and terminate\n  # all active sockets and channels for a given user:\n  #\n  #     ChatWeb.Endpoint.broadcast(\"user_socket:#{user.id}\", \"disconnect\", %{})\n  #\n  # Returning `nil` makes this socket anonymous.\n  def id(_socket), do: nil\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/chat_web/controllers/page_controller.ex","source":"defmodule ChatWeb.PageController do\n  use ChatWeb, :controller\n\n  def index(conn, _params) do\n    render conn, \"index.html\"\n  end\nend","coverage":[null,null,null,null,1,null,null]},{"name":"lib/chat_web/endpoint.ex","source":"defmodule ChatWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :chat\n\n  socket \"/socket\", ChatWeb.UserSocket\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phoenix.digest\n  # when deploying your static files in production.\n  plug Plug.Static,\n    at: \"/\", from: :chat, gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n  end\n\n  plug Plug.Logger\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Poison\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  plug Plug.Session,\n    store: :cookie,\n    key: \"_chat_key\",\n    signing_salt: \"yXTb3Aqi\"\n\n  plug ChatWeb.Router\n\n  @doc \"\"\"\n  Callback invoked for dynamically configuring the endpoint.\n\n  It receives the endpoint configuration and checks if\n  configuration should be loaded from the system environment.\n  \"\"\"\n  def init(_key, config) do\n    if config[:load_from_system_env] do\n      port = System.get_env(\"PORT\") || raise \"expected the PORT environment variable to be set\"\n      {:ok, Keyword.put(config, :http, [:inet6, port: port])}\n    else\n      {:ok, config}\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,0,null,null,null,null,null,null]},{"name":"lib/chat_web/gettext.ex","source":"defmodule ChatWeb.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import ChatWeb.Gettext\n\n      # Simple translation\n      gettext \"Here is the string to translate\"\n\n      # Plural translation\n      ngettext \"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3\n\n      # Domain-based translation\n      dgettext \"errors\", \"Here is the error message to translate\"\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :chat\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/chat_web/router.ex","source":"defmodule ChatWeb.Router do\n  use ChatWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", ChatWeb do\n    pipe_through :browser # Use the default browser stack\n\n    get \"/\", PageController, :index\n  end\n\n  # Other scopes may use custom stacks.\n  # scope \"/api\", ChatWeb do\n  #   pipe_through :api\n  # end\nend","coverage":[null,null,null,1,null,null,null,null,null,null,null,0,null,null,null,null,null,null,1,null,null,null,null,null,null,null]},{"name":"lib/chat_web/views/error_helpers.ex","source":"defmodule ChatWeb.ErrorHelpers do\n  @moduledoc \"\"\"\n  Conveniences for translating and building error messages.\n  \"\"\"\n\n  use Phoenix.HTML\n\n  @doc \"\"\"\n  Generates tag for inlined form input errors.\n  \"\"\"\n  def error_tag(form, field) do\n    Enum.map(Keyword.get_values(form.errors, field), fn (error) ->\n      content_tag :span, translate_error(error), class: \"help-block\"\n    end)\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # When using gettext, we typically pass the strings we want\n    # to translate as a static argument:\n    #\n    #     # Translate \"is invalid\" in the \"errors\" domain\n    #     dgettext \"errors\", \"is invalid\"\n    #\n    #     # Translate the number of files with plural rules\n    #     dngettext \"errors\", \"1 file\", \"%{count} files\", count\n    #\n    # Because the error messages we show in our forms and APIs\n    # are defined inside Ecto, we need to translate them dynamically.\n    # This requires us to call the Gettext module passing our gettext\n    # backend as first argument.\n    #\n    # Note we use the \"errors\" domain, which means translations\n    # should be written to the errors.po file. The :count option is\n    # set by Ecto and indicates we should also apply plural rules.\n    if count = opts[:count] do\n      Gettext.dngettext(ChatWeb.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(ChatWeb.Gettext, \"errors\", msg, opts)\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null]},{"name":"lib/chat_web/views/error_view.ex","source":"defmodule ChatWeb.ErrorView do\n  use ChatWeb, :view\n\n  # If you want to customize a particular status code\n  # for a certain format, you may uncomment below.\n  # def render(\"500.html\", _assigns) do\n  #   \"Internal Server Error\"\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def template_not_found(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null]},{"name":"lib/chat_web/views/layout_view.ex","source":"defmodule ChatWeb.LayoutView do\n  use ChatWeb, :view\nend","coverage":[null,null,null]},{"name":"lib/chat_web/views/page_view.ex","source":"defmodule ChatWeb.PageView do\n  use ChatWeb, :view\nend","coverage":[null,null,null]}]}